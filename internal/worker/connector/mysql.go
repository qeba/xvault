package connector

import (
	"database/sql"
	"fmt"
	"os"
	"strings"

	_ "github.com/go-sql-driver/mysql"
)

// MySQLConfig represents MySQL connection configuration
type MySQLConfig struct {
	Host     string
	Port     int
	Database string
	Username string
	Password string
}

// MySQLConnector handles MySQL/MariaDB connections for database dumps
type MySQLConnector struct {
	config *MySQLConfig
}

// NewMySQLConnector creates a new MySQL connector
func NewMySQLConnector(config *MySQLConfig) *MySQLConnector {
	return &MySQLConnector{
		config: config,
	}
}

// Connect establishes a MySQL connection
func (c *MySQLConnector) Connect() (*sql.DB, error) {
	// Build DSN (Data Source Name)
	// Format: username:password@tcp(host:port)/database
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true",
		c.config.Username,
		c.config.Password,
		c.config.Host,
		c.config.Port,
		c.config.Database,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Test connection
	if err := db.Ping(); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

// DumpDatabase exports the database to a SQL dump file
// This creates a mysqldump-compatible SQL file
func (c *MySQLConnector) DumpDatabase(db *sql.DB, destPath string) (*DumpStats, error) {
	stats := &DumpStats{
		DatabaseName: c.config.Database,
	}

	// Create output file
	file, err := os.Create(destPath)
	if err != nil {
		return stats, fmt.Errorf("failed to create dump file: %w", err)
	}
	defer file.Close()

	// Write header
	header := fmt.Sprintf("-- xVault MySQL/MariaDB Dump\n-- Host: %s:%d\n-- Database: %s\n-- Generated by xVault\n\n",
		c.config.Host, c.config.Port, c.config.Database)
	if _, err := file.WriteString(header); err != nil {
		return stats, fmt.Errorf("failed to write header: %w", err)
	}

	// Set character set and disable foreign key checks for faster import
	if _, err := file.WriteString("SET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n"); err != nil {
		return stats, fmt.Errorf("failed to write prelude: %w", err)
	}

	// Get list of tables
	tables, err := c.getTables(db)
	if err != nil {
		return stats, fmt.Errorf("failed to get tables: %w", err)
	}

	stats.TablesProcessed = len(tables)

	// Dump each table
	for _, table := range tables {
		tableStats, err := c.dumpTable(db, file, table)
		if err != nil {
			return stats, fmt.Errorf("failed to dump table %s: %w", table, err)
		}
		stats.TotalRows += tableStats.Rows
		stats.SizeBytes += tableStats.SizeBytes
	}

	// Write footer
	if _, err := file.WriteString("\nSET FOREIGN_KEY_CHECKS = 1;\n"); err != nil {
		return stats, fmt.Errorf("failed to write footer: %w", err)
	}

	// Get file size
	fileInfo, err := file.Stat()
	if err != nil {
		return stats, fmt.Errorf("failed to get file info: %w", err)
	}
	stats.SizeBytes = fileInfo.Size()

	return stats, nil
}

// getTables returns a list of all tables in the database
func (c *MySQLConnector) getTables(db *sql.DB) ([]string, error) {
	query := `
		SELECT TABLE_NAME
		FROM INFORMATION_SCHEMA.TABLES
		WHERE TABLE_SCHEMA = ? AND TABLE_TYPE = 'BASE TABLE'
		ORDER BY TABLE_NAME
	`

	rows, err := db.Query(query, c.config.Database)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tables []string
	for rows.Next() {
		var tableName string
		if err := rows.Scan(&tableName); err != nil {
			return nil, err
		}
		tables = append(tables, tableName)
	}

	return tables, rows.Err()
}

// dumpTable dumps a single table's schema and data
func (c *MySQLConnector) dumpTable(db *sql.DB, file *os.File, tableName string) (*TableDumpStats, error) {
	stats := &TableDumpStats{}

	// Write table drop and create statement
	createSQL, err := c.getCreateTableSQL(db, tableName)
	if err != nil {
		return stats, fmt.Errorf("failed to get create table SQL: %w", err)
	}

	if _, err := file.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n", tableName)); err != nil {
		return stats, err
	}
	if _, err := file.WriteString(createSQL + ";\n\n"); err != nil {
		return stats, err
	}

	// Dump table data
	rows, err := db.Query(fmt.Sprintf("SELECT * FROM `%s`", tableName))
	if err != nil {
		return stats, fmt.Errorf("failed to query table: %w", err)
	}
	defer rows.Close()

	// Get column names
	columns, err := rows.Columns()
	if err != nil {
		return stats, fmt.Errorf("failed to get columns: %w", err)
	}

	if len(columns) == 0 {
		return stats, nil
	}

	// Build INSERT statement
	insertPrefix := fmt.Sprintf("INSERT INTO `%s` (`%s`) VALUES ", tableName, strings.Join(columns, "`, `"))

	rowCount := 0
	values := make([]interface{}, len(columns))
	valuePtrs := make([]interface{}, len(columns))

	for rows.Next() {
		for i := range columns {
			valuePtrs[i] = &values[i]
		}

		if err := rows.Scan(valuePtrs...); err != nil {
			return stats, fmt.Errorf("failed to scan row: %w", err)
		}

		// Format values as SQL literals
		valueStrings := make([]string, len(columns))
		for i, val := range values {
			valueStrings[i] = formatSQLValue(val)
		}

		if _, err := file.WriteString(insertPrefix + "(" + strings.Join(valueStrings, ", ") + ");\n"); err != nil {
			return stats, err
		}

		rowCount++
	}

	stats.Rows = int64(rowCount)
	return stats, rows.Err()
}

// getCreateTableSQL returns the CREATE TABLE statement for a table
func (c *MySQLConnector) getCreateTableSQL(db *sql.DB, tableName string) (string, error) {
	var createSQL string
	query := fmt.Sprintf("SHOW CREATE TABLE `%s`", tableName)

	err := db.QueryRow(query).Scan(&tableName, &createSQL)
	if err != nil {
		return "", err
	}

	return createSQL, nil
}

// formatSQLValue formats a value as a SQL literal
func formatSQLValue(val interface{}) string {
	if val == nil {
		return "NULL"
	}

	switch v := val.(type) {
	case []byte:
		// Treat as string
		return fmt.Sprintf("'%s'", escapeSQLString(string(v)))
	default:
		// For other types, use Sprint and escape if it looks like a string
		str := fmt.Sprintf("%v", v)
		return fmt.Sprintf("'%s'", escapeSQLString(str))
	}
}

// escapeSQLValue escapes special characters in SQL strings
func escapeSQLString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "'", "\\'")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\t", "\\t")
	s = strings.ReplaceAll(s, "\x00", "\\0")
	return s
}

// DumpStats contains statistics about the database dump
type DumpStats struct {
	DatabaseName   string
	TablesProcessed int
	TotalRows      int64
	SizeBytes      int64
}

// TableDumpStats contains statistics about a single table dump
type TableDumpStats struct {
	Rows     int64
	SizeBytes int64
}
